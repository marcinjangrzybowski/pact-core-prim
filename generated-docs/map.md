# map

## Basic syntax

To use the `map` function, leverage the following syntax:

```pact
(map *function-APP* *element-LIST*)
```

Here, `*function-APP*` is the function to be applied to each element in the list and `*element-LIST*` is the list on which the function will be applied. The `map` function applies the `*function-APP*` to each element in `*element-LIST*`, returning a new list of results.

For example:

```pact
(map (+ 1) [1 2 3])
```

In this example, the `map` function applies the `(+ 1)` function to each element in the `[1 2 3]` list. This will return a new list - `[2 3 4]` - with each element being the result of the `(+ 1)` function.

## Arguments

| Argument | Type | Description |
| --- | --- | --- |
| f | _a_ -> _b_ | It is a function that should take argument of any type _a_ and return the result of type _b_. The function is applied to each element of the list.
| as |[_a_]| It is a list where each element is of type _a_. The function `f` is applied to each element of this list.  |


## Prerequisites

N/A

## Return values

The `map` function returns a new list where each element is the result of applying the specified function to the corresponding element in the input list. The type of the returned values in the list is determined by the function applied.
 
For example, using `(map (+ 1) [1 2 3])` returns `[2 3 4]` as the `+ 1` function is applied to each element of the input list `[1 2 3]`, yielding a new list where every element is incremented by 1. 

In the case of `(map (int-to-str 10) (enumerate 0 19))` used in the code snippets above, the map function applies the `int-to-str` function to each element of the list generated by `(enumerate 0 19)`, resulting in a list of strings.

This returned list can be used in diverse situations where transformations of all elements in a list are needed.

## Examples

The `map` function in Pact takes a function and a list as arguments and applies the function to each element of the list, returning a new list with the results.

Here are a few examples of using the `map` function:

This example increments each number in a list:

```pact
(map (+ 1) [1 2 3])
```

Output: 

```pact
[2 3 4]
```

This example converts each integer to a string in a list:

```pact
(defconst VALID_CHAIN_IDS (map (int-to-str 10) (enumerate 0 19)))
```

This example removes 'module-hash' from each event in a list:

```pact
(map (remove 'module-hash) (env-events true))
```


## Options

N/A

## Property validation

For property validation, you can use the `map` function in the specification of invariants and properties to test your code. The `map` function applies a single argument function (`f`: _a_ -> _b_) to every element in a list ([_a_]) and produces a new list containing the results ([_b_]). Be cautious to ensure the applied function and the list elements are of compatible types to avoid validation errors.

## Gotchas

One common pitfall when using the `map` function is providing a function that does not match the data type of the list elements it is meant to transform. The function passed to `map` should expect arguments of the same type as the elements of the list it operates on. For example, if your list contains integers, the function you pass to `map` should also work with integers. Otherwise, the `map` function will return an error.

Another potential issue arises when attempting to map an empty list. Although `map` will not throw an error in this case, it will simply return an empty list, which might not be the expected behavior for some users.

Remember, the `map` function returns a new list and does not modify the original list. This might lead to unexpected results for users expecting the `map` function to modify the original list. For instance, if you assign the result of `map` to a new variable and subsequently modify the original list, the changes will not be reflected in the list produced by `map`.

Hence, be certain of the types of elements in your list and be certain what you want to achieve when using `map`, it is a powerful function but can lead to unexpected results if not used correctly.

