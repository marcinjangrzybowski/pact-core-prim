
# ⚠️ ☠️ 🔮 🤖 CRITICAL DISCLAIMER ⚠️

 
This document is **AUTO-GENERATED** using a Large Language Model. While the generation process employs legacy documentation, code snippets, and human-like AI language processing, it is **NOT GUARANTEED TO BE ACCURATE OR COMPLETE.** The AI is fundamentally limited, being incapable of understanding the nuances of human-written code in the way a skilled developer would. This document exists primarily as an initial draft meant to *assist* technical writers, not to replace their essential work. It is *critical* for all contents presented here to be meticulously reviewed, cross-checked, and validated against the original source code. 🚫 **DO NOT REMOVE** this disclaimer without comprehensive and informed review of the entire document. Proceed with extreme caution! Do not trust this document without verification!

# map

## Basic syntax

The `map` function is a higher order function which applies a function to each element in a list, returning a new list of results. It's basic syntax can be captured as:

```pact
(map *function* *list*)
```

Here, `*function*` is the application that will be applied to each element. It should be a function that takes an argument of any valid pact data type and returns a result of any desired data type.

The `*list*` is the list of elements that the *function* will be applied on. This should be a valid list of elements with a data type that the *function* can be applied on.

The `map` function then returns a new list where each element in the *list* has had the *function* applied on it.

Here's an example usage of the `map` function:

```pact
(map (+ 1) [1 2 3])
```

In the above snippet, the `map` function applies the function `(+ 1)` to the list `[1 2 3]`, resulting in the list `[2 3 4]`, because `(+1) ` is applied on each element of the list `[1 2 3]`.

## Arguments

| Argument | Type | Description |
| --- | --- | --- |
| f | function(*a* -> *b*) | A function applied to each element in the list. Can be any function that takes a single argument of any type and returns any type |
| as | list[*a*] | Specifies the list of values to which the function `f` will be applied.

## Prerequisites

N/A

## Return values

The `map` function returns a list with transformed elements. The contents of the new list are results of applying a provided function to each element of the original list. The returned list will have the same length as the input list. The returned value is particularly useful when you need to apply a certain calculation or transformation to every element of a list, and track the results in a new list.

## Examples

Here are a few examples illustrating how to use the `map` function:

```pact
(map (+ 1) [1 2 3])
```
In this example, the `map` function applies `(+ 1)` to each element in the list `[1 2 3]`, resulting in a new list `[2 3 4]`.

```pact
(map (int-to-str 10) (enumerate 0 19))
```
In this second example, two functions are being applied simultaneously. Firstly `(enumerate 0 19)` generates a list of numbers from 0 to 19. Subsequently, `(int-to-str 10)` is applied to each of these numbers converting them into strings. The `map` function thus produces a list of strings.

```pact
(map (remove 'module-hash) (env-events true))
```
In this third example, the `map` function is used to sanitize event data. It removes a specific 'module-hash' field from each event in the list returned by `(env-events true)`.

Remember, each example provided is demonstrating a different aspect of the `map` function. The first one is using `map` with a simple addition operation, the second one is using it for converting data types and the last one is showing how map can be used in a real-world application to sanitize data.

Remember to replace test values with real ones when implementing these functions in your own projects.

## Options

N/A

## Property validation

The `map` function can be used in property or invariant definitions to validate a certain condition across all elements in a list. It applies a given function to each element in the list, which might contain property or validity checks. 

However, `map` itself does not perform any internal property validation. Its operation depends entirely on the function that is passed as an argument.

If the input function to `map` imposes any restrictions or conditions, those will be enforced when the `map` function iterates over the items in the list.

For example, you could pass an input function to `map` that checks for a certain threshold on all elements in the list or performs specific data type checks. However, these validity checks are imposed by the input function, not by `map` itself.

For any invalid arguments or error conditions, the `map` function will return an error message that is generated by Pact itself, not by the `map` function. The nature of the returned error message will depend on the nature of the invalid argument or error condition.

## Gotchas

While using `map`, you should be aware of the following potential issues:

1. The `map` function requires two arguments: a function and a list. It will return a list with the results of applying the function to each element. However, if you accidentally provide a non-list item as the second argument, the function will fail with an error. Hence, always ensure that the second argument is a list.

2. The provided function should be able to process all elements of the list. If the function cannot handle one of the elements (due to type mismatch or other issues), the `map` function will fail as well. 

3. The `map` function doesn't modify the original list; it returns a new list with the transformed elements. If you need to use the transformed list further in your code, remember to store its results in a variable.

4. Lastly, note that `map` doesn't return a value instantly; it's a lazy function, meaning it returns an iterator that computes the values as needed. If you need a list as the result (e.g., for indexing), you should convert the result to a list explicitly.

